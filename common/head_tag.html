<script type="text/discourse-plugin" version="0.1">
  let words = {};
  let regexes = {};
  let hasWords = hasRegexes = false;
  if (settings.linked_words === '') {
    return;
  }
  settings.linked_words.split('|').forEach(pair => {
    if (!pair.includes(',')) {
        return;
    }
    let split = pair.split(",");
    if (pair[0] === '/') {
      let url = split.pop().trim();
      let regex = split.join(",");
      if (url === '' || regex === '') {
          return;
      }
      regexes[regex] = url;
      hasRegexes = true;
    } else {
      let word = split[0].toLowerCase().trim();
      let url = split[1].trim();
      if (word === '' || url === '') {
          return;
      }
      words[word] = url;
      hasWords = true;
    }
  });

  if (!hasWords && !hasRegexes) {
    return;
  }

  // roughly guided by https://stackoverflow.com/questions/8949445/javascript-bookmarklet-to-replace-text-with-a-link
  let skipTags = {
    'a': 1,
    'iframe': 1,
  };

  settings.excluded_tags.split('|').forEach(tag => {
    skipTags[tag] = 1;
  });

  let escapeRegExp = function(str) {
     return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  
  let leftWordBoundary = "(\\s|[\\([{]|^)";
  let rightWordBoundary = "([:.;,!?â€¦\\]})]|\\s|$)";
    
  let wordsRegex;
  if (hasWords) { 
    let keys = Object.keys(words).sort((x,y) => y.length - x.length);
    let escapedWords = "((" + keys.map(w => escapeRegExp(w)).join(")|(") + "))";
    wordsRegex = new RegExp(leftWordBoundary + escapedWords + rightWordBoundary, "ig");
  }

  let createLink = function(text) {
      let lower = text.toLowerCase();
      let href = words[lower];
      var link = document.createElement('a');
      link.innerHTML = text;
      link.href = href;
      link.rel = 'nofollow';
      link.target = '_blank';
      link.className = 'linkify-word no-track-link';
      return link;
  };
  
  let createLinkFromRegex = function(text, regex, captured) {
      let href = regexes[regex];
      for (let i = captured.length; i > 0; i--) {
          let re = new RegExp("\\$" + i.toString(), "");
          href = href.replace(re, captured[i-1]);
      }
      var link = document.createElement('a');
      link.innerHTML = text;
      link.href = href;
      link.rel = 'nofollow';
      link.target = '_blank';
      link.className = 'linkify-word no-track-link';
      return link;
  };

  let autolink = function(text) {
      let match, matches = [];
      if (hasWords) {
        while (match = wordsRegex.exec(text.data)) {
          matches.push(match);
        }
      }
      // got to work backwards not to muck up string
      for (let i = matches.length - 1; i >= 0; i--) {
          match = matches[i];
          text.splitText(match.index + match[1].length);
          text.nextSibling.splitText(match[2].length);
          text.parentNode.replaceChild(createLink(match[2]), text.nextSibling);
      }
      
      for (regex in regexes) {
          // Remove boundary backslashes
          let reg = regex.split("/");
          if (reg.length !== 3) {
              console.log("ERROR from auto-linkify theme: Invalid regular expression:");
              console.log(regex);
              continue;
          }
          let modifier = reg.pop();
          reg = reg.slice(1).join("/");
          // Allow only "i" modifier for now
          if (modifier !== "i" && modifier !== "") {
            modifier = "";
          }
          try {
            reg = new RegExp(leftWordBoundary + "(" + reg + ")" + rightWordBoundary, modifier + "g");
          }
          catch(err) {
            console.log("ERROR from auto-linkify theme: Invalid regular expression:");
            console.log(regex);
            console.log(err.message);
            continue;
          }

          match = null;
          matches = [];
          while (match = reg.exec(text.data)) {
            matches.push(match);
          }
          // got to work backwards not to muck up string
          for (let i = matches.length - 1; i >= 0; i--) {
            match = matches[i];
            text.splitText(match.index + match[1].length);
            text.nextSibling.splitText(match[2].length);
            // Did we capture user defined variables?
            // By default, we capture 3 vars: left boundary, the regex itself, right boundary
            let capturedVariables = [];
            if (match.length > 4) {
              capturedVariables = match.slice(3, match.length-1);
            }
            text.parentNode.replaceChild(createLinkFromRegex(match[2], regex, capturedVariables), text.nextSibling);
          }
      }
  }

  let linkify = function(elem) {
      // work backwards so changes do not break iteration
      for(let i = elem.childNodes.length - 1; i >=0; i--) {
        let child = elem.childNodes[i];
        if (child.nodeType === 1) {
            let tag = child.nodeName.toLowerCase();
            if (!(tag in skipTags)) {
                linkify(child);
            }
        } else if (child.nodeType === 3) {
            autolink(child);
        }
      }
  }

  api.decorateCooked($elem => {
    linkify($elem[0]);
  });
</script>
